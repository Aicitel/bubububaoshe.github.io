<!DOCUMENTTYPE html>
<html>
<head>
	<title>千秋戏</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="height=device-height,
                      width=device-width, initial-scale=1.0,
                      minimum-scale=1.0, maximum-scale=1.0,
                      user-scalable=no">
  <link rel="shortcut icon" type="image/x-icon" href="img/favicon.ico"/>
	<link rel="stylesheet" type="text/css" href="segmented-controls.css">
	<link rel="stylesheet" type="text/css" href="main.css">
	<link rel="stylesheet" type="text/css" href="decks.css">
	<link rel="stylesheet" type="text/css" href="notifications.css">
	<link rel="stylesheet" type="text/css" href="tableinfo.css">
</head>

<body class="noselect">
	<div id="configurator" class="flexbox transitopacity">
		<div id="modeinput" class="segmented-control" style="width: 100%; color: #334422">
			<input type="radio" name="gamemode" id="vs_ai"     checked onclick='SetGameMode(1);'>
			<input type="radio" name="gamemode" id="vs_player" onclick='SetGameMode(2);'>
			<label for="vs_ai"     data-value="独享的快乐">单人游戏</label>
			<label for="vs_player" data-value="双倍的快乐">双人对战</label>
		</div>
		<hr/>
		<div id="multiplayerinfo" style="width:100%; color:#112211">
			<div style="width: 100%;">
			<div id="lobbystatus">
			当前在线人数：未知
			</div>
			<div id="myplayerid">
			（ID）
			</div>
			<div id="refresh_lobbystatus">
			[刷新]
			</div>
			</div>
		</div>
		<div id="multiplayertypeinput" class="segmented-control" style="width: 50%; color: #281B11">
			<input type="radio" name="multiplayertype" id="multiplayertype1" checked>
			<input type="radio" name="multiplayertype" id="multiplayertype2">
			<label for="multiplayertype1" data-value="选人一起玩">选人一起玩</label>
			<label for="multiplayertype2" data-value="随机匹配小伙伴">随机匹配小伙伴</label>
		</div>
		<div id="room_buttons" style="width: 100%; margin-bottom: 0.5vw; margin-top: 0.5vw">
			<div id="inviteinput" class="inviteinput" style="width:35%">
			对方ID：<input id="invitedid" type="text" size=5></input>
			</div>
			<div id="invitebutton">
			邀请之
			</div>
			</div>
			<div id="match_buttons" style="width: 100%; margin-bottom: 0.5vw; margin-top: 0.5vw">
			<div id="start_match" style="background-color:#CCCC66;">随机寻找对手</div>
			</div>
			<div id="confirm_cancel_buttons" style="width:100%; margin-bottom: 0.5vw; margin-top: 0.5vw"> 
			<div id="confirm_match" style="background-color:#66CC66;display:none">确认配对</div>
			<div id="cancel_match" style="background-color:#CC6666;display:none">放弃配对</div>
			<div style="background-color:#6666CC;" onclick='AUTOTEST_autostartmatch();'>T E S T</div>
		</div>
		<hr/>
		<div id="packinput" class="segmented-control" style="width: 100%; color: #281B11">
			<input type="radio" name="version" id="p12" checked>
			<input type="radio" name="version" id="p13" disabled="true">
			<input type="radio" name="version" id="p23" disabled="true">
			<label for="p12" data-value="1+2 代人物">1+2</label>
			<label for="p13" data-value="1+3 代人物">1+3</label>
			<label for="p23" data-value="2+3 代人物">2+3</label>
		</div>
		<div id="voiceinput" class="segmented-control" style="width: 100%; color: #281B11">
			<input type="radio" name="voice" id="voiceon" checked>
			<input type="radio" name="voice" id="voiceoff">
			<label for="voiceon" data-value="完成组合时播放语音">语音</label>
			<label for="voiceoff" data-value="完成组合时BlueBlue">无语音</label>
		</div>
		<div id="aiinput" class="segmented-control" style="width: 100%; color: #281B11">
			<input type="radio" name="ai" id="ai1">
			<input type="radio" name="ai" id="ai2" checked>
			<input type="radio" name="ai" id="ai3" >
			<label for="ai1" data-value="温和亲切的AI">炤级AI</label>
			<label for="ai2" data-value="沉迷种田的AI">洛级AI</label>
			<label for="ai3" data-value="恶意满满的AI">危级AI</label>
		</div>
		<div id="spinput" class="segmented-control" style="width: 100%; color: #281B11">
			<input type="radio" name="sp" id="sp0">
			<input type="radio" name="sp" id="sp1" checked>
			<input type="radio" name="sp" id="sp2">
			<input type="radio" name="sp" id="sp3">
			<label for="sp0" data-value="AI不想使用珍稀牌">AI无珍稀牌</label>
			<label for="sp1" data-value="AI珍稀牌量是你一半">AI 1/2珍稀牌</label>
			<label for="sp2" data-value="AI珍稀牌量和你一样">AI等量珍稀牌</label>
			<label for="sp3" data-value="AI拥有所有珍稀牌">AI全珍稀牌</label>
		</div>
		<div id="comfirmSetting" class="confirmbutton">确定</div>
	</div>
	<div id="spselection" class="transitopacity">
		<div class="selectionarea verticalflex">
			<div>
				<div id="sprepo" class="charinfocontainer flexbox"></div>
				<div class="cover"></div>
			</div>
			<div><div id="sppick" class="charinfocontainer flexbox"></div></div>
		</div>
		<div class="rightsidebar verticalflex">
			<div></div>
			<div id="selectioninfo" class="centeredtext"><div>从上方牌库
选择特殊牌
到下方牌组
最多选15张</div></div>
			<div id="gamestart" class="centeredtext"><div>开始
游戏</div></div>
		</div>
	</div>
	<div id="main">
		<div id="scoreboard">
			<div id="table0" class="cardstack"></div>
			<div id="score0" class="bignotice">
				<div></div>
				<div class="combobonus">
				</div>
			</div>
			<div id="infobox" class="centeredtext bignotice"><div></div></div>
			<div id="score1" class="bignotice">
				<div></div>
				<div class="combobonus"></div>
			</div>
			<div id="table1" class="cardstack"></div>
		</div>
		<div id="gamezonecontainer">
			<div id="gamezone">
				<div id="hand0container"><div id="hand0"></div></div>
				<div id="poolcontainer">
					<div id="pool"></div>
					<div id="repository"></div>
				</div>
				<div id="hand1container"><div id="hand1"></div></div>
				<div id="blocker" class="cover"></div>
				<div id="finalcontainer" class="cover">
					<div></div><div></div><div></div>
					<div>
						<div id="finalmsg" class="bignotice">你赢了</div>
						<p>点击牌桌区域继续</p>
					</div>
					<p class="string"></p>
				</div>
				<div class="tableinfocontainer cover transitopacity">
					<div class="charinfocontainer flexbox"></div>
					<div class="charinfocontainer flexbox"></div>
				</div>
			</div>
			<div class="tableinfocontainer cover transitopacity">
				<div class="infoheader bignotice">
						<div>&#9830; 对方卡牌</div>
						<div>&#9830; 完成组合</div>
						<div>&#9830; 未完组合</div>
					</ul>
				</div>
				<div class="charinfocontainer flexbox"></div>
				<div class="ccomboinfocontainer flexbox"></div>
				<div class="icomboinfocontainer flexbox"></div>
			</div>
			<div class="tableinfocontainer cover transitopacity">
				<div class="infoheader bignotice">
						<div>&#9830; 我方卡牌</div>
						<div>&#9830; 完成组合</div>
						<div>&#9830; 未完组合</div>
					</ul>
				</div>
				<div class="charinfocontainer flexbox"></div>
				<div class="ccomboinfocontainer flexbox"><!--
					<div class="combocard">
						<div>
							<div class="thumbnailcard" style="background-Image:url('img/oysg1.jpg')"></div>
						</div>
						<div>
							<div id="combocardinfo">
								<div>老板</div>
								<div>90</div>
							</div>
							<div id="combocardchars">
								<span class="ismine">欧阳少恭</span><span class="notmine">沈夜</span>
							</div>
						</div>
					</div>-->
				</div>
				<div class="icomboinfocontainer flexbox"></div>
			</div>
			<div class="tableinfocontainer cover">
				<div class="infoheader bignotice">
						<div>&#9830; 我方珍稀牌</div>
				</div>
				<div class="charinfocontainer specials flexbox"></div>
			</div>
		</div>
		<div id="specialboard">
			<div id="specials0" class="cardstack"></div>
			<div id="hoverinfobox" class="bignotice"><div></div></div>
			<div id="specials1" class="cardstack"></div>
		</div>
	</div>
	<div id="infobanner" class="cover transitopacity banner">
		<div>
			<div class="bannertext">
				<span></span><span class="bannerhl"></span><span></span><span class="bannerhl"></span><span></span>
			</div>
			<div class="bannercards"><!--
				<div class="swapposter">
				<div></div>
					<div class="postercard"></div>
				</div>
				<div class="swapposter">
					<div></div>
					<div class="postercard" style="background-image:url(img/wz3.jpg)"></div>
				</div>-->
			</div>
		</div>
	</div>
	<audio id="soundeffect" src=""></audio>
</body>
</html>
<script src="tricks.js"></script>
<script src="model.js"></script>
<script src="controller.js"></script>
<script src="spmanager.js"></script>
<script src="tableinfoview.js"></script>
<script src="view.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript">

  // New variables for multiplayer mode
  var is_my_move = false;
  var g_my_player_id = -999;
  var is_multiplayer = false;
  var versus_rank = -999; // 0:先手； 1:后手
  var remoteObtainActions = null;
  
  // Test
  var is_verify_per_round = false;
  var combo_notify_method = 1; // 1: 双方都显示全屏大通知
                               // 2: 发起方显示大通知，接收方显示小通知
  var is_sync_on_sound = true; // 仅对2有效
                               // 我觉得 因为postObtain中有个发牌动作 而postObtain前放音频 所以需要sync
  function ShouldSyncOnSound() {
    return (combo_notify_method == 2 && is_sync_on_sound == true);
  }
  
  // Barrier for "Obtain" stuff
  var turnActionCount = 0;
  function IncrementActionBarrier() {
    turnActionCount += 1;
  }
  function DecrementActionBarrier() {
    if (is_multiplayer != true) return;
    turnActionCount -= 1;
    if (turnActionCount == 0) {
      console.log('<<< 行动完了');
      console.log('MyCardsCount: ' + model.getMyCardsCount());
      if (is_verify_per_round == true)
        socket.emit('Game_ObtainEnd', model.getSnapshot());
      else
        socket.emit('Game_ObtainEnd');
    }
  }
  
  // 按键事件
  document.getElementById("refresh_lobbystatus").addEventListener("click", function() {
    socket.emit('Info_RefreshOnlinePlayerCount');
  });
  document.getElementById("cancel_match").addEventListener("click", function(){
    socket.emit('Match_CancelMatch');
    lobbystatus.textContent = "你取消了匹配";
    document.getElementById("start_match").style.display = "inline-block";
    document.getElementById("confirm_match").style.display = "none";
    document.getElementById("cancel_match").style.display = "none";
  });
  document.getElementById("multiplayertype1").addEventListener("click", function(){
    SetMultiplayerMode(1);
  });
  document.getElementById("multiplayertype2").addEventListener("click", function(){
    SetMultiplayerMode(2);
  });
  
  function SetGameMode(m) {
    if (m == 1) { // 单人模式
      //document.getElementById("multiplayerinputs").style.display="none";
      document.getElementById("singleplayerinputs").style.display="block";
    } else { // 对战模式
      //document.getElementById("multiplayerinputs").style.display="block";
      //document.getElementById("singleplayerinputs").style.display="none";
      
      document.getElementById("start_match").style.display = "inline-block";
      document.getElementById("confirm_match").style.display = "none";
      document.getElementById("cancel_match").style.display = "none";
    }
  }
  function SetMultiplayerMode(m) {
    ShowMultiplayerStep2();
  }
  
  // 多人的Step1:选择是邀请指定玩家还是随机寻找对手
  
  // 多人的Step2：如果是邀请 就需要输入对方ID
  //            如果是随机 就要按一下”随机寻找对手“
  function ShowMultiplayerStep2() {
    if (document.getElementById('multiplayertype1').checked == true) { // 邀
      document.getElementById("room_buttons").style.display = "block";
      document.getElementById("match_buttons").style.display = "none";
    } else if (document.getElementById('multiplayertype2').checked == true) {
      document.getElementById("room_buttons").style.display = "none";
      document.getElementById("match_buttons").style.display = "block";
    }
  }
  
  function HideMultiplayerStep2() {
    document.getElementById("room_buttons").style.display = "none";
    document.getElementById("match_buttons").style.display = "none";
  }
  
  function ShowMultiplayerStep3() {
    document.getElementById('match_buttons').style.display = "block";
  }
  
  function HideMultiplayerStep3() {
    document.getElementById('match_buttons').style.display = "none";
  }
  
  // 开始匹配或开始等人时就不能改设置了
  function FixMultiplayerRoomSettings() {
    document.getElementById('prestriction1').disabled = true;
    document.getElementById('prestriction2').disabled = true;
  }
  function UnfixMultiplayerRoomSettings() {
    document.getElementById('prestriction1').disabled = false;
    document.getElementById('prestriction2').disabled = false;
  }
  
  // 邀请指定玩家
  // 如果邀请成功就当作匹配成功来处理...
  document.getElementById("invitebutton").addEventListener("click", function(){
    var invited_id = document.getElementById("invitedid").value;
    console.log('Invite ' + invited_id);
    socket.emit('Match_InvitePlayer', invited_id);
  });
  
  // 开始匹配
  document.getElementById("start_match").addEventListener("click", function() {
    socket.emit('Match_ReadyToMatch');
  });
  document.getElementById("confirm_match").addEventListener("click", function() {
    socket.emit('Match_ConfirmMatch');
  });
  // 来自服务器的消息
  var lobbystatus = document.getElementById("lobbystatus");
  socket = io.connect();
  socket.on('Info_OnlinePlayerCount', function(n) {
    lobbystatus.innerHTML = "当前人数："+n;
  });
  socket.on('Info_MyPlayerId', function(pid) {
    g_my_player_id = pid;
    document.getElementById('myplayerid').textContent = 'ID: ' + pid;
  });
  socket.on('Match_ReadyToMatchAck', function() {
    document.getElementById("start_match").style.display = "none";
    document.getElementById("confirm_match").style.display = "none";
    document.getElementById("cancel_match").style.display = "inline-block";
    lobbystatus.innerHTML = "正在寻找同伴中";
  });
  socket.on('Match_FoundMatch', function(reason) {
    // 邀请模式下，如果找到了被邀请的人，也走这里
    HideMultiplayerStep2();
    ShowMultiplayerStep3();
    
    document.getElementById("start_match").style.display = "none";
    document.getElementById("confirm_match").style.display = "inline-block";
    document.getElementById("cancel_match").style.display = "inline-block";
    lobbystatus.innerHTML = reason;
  });
  socket.on('Match_ConfirmMatchAck', function(msg) {
    lobbystatus.innerHTML = msg;
  });
  socket.on('Match_OtherPlayerConfirmed', function() {
    lobbystatus.innerHTML = "对方玩家已确认";
  });

  var AUTOTEST = true;
  socket.on('Room_PlayerDisconnected', () => {
    console.log('对方玩家已离线');
  });
  
  socket.on('Match_OtherPlayerCancelsMatch', () => {
    HideMultiplayerStep3();
    ShowMultiplayerStep2();
    document.getElementById('lobbystatus').textContent = '对方取消了匹配';
    document.getElementById("start_match").style.display = "inline-block";
    document.getElementById("confirm_match").style.display = "none";
    document.getElementById("cancel_match").style.display = "none";
  });
  
  socket.on('Match_InvalidInvitation', (reason) => {
    lobbystatus.textContent = reason;
    console.log('邀请不成功' + reason);
  });
  
  // https://stackoverflow.com/questions/951021/what-is-the-javascript-version-of-sleep
  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // StressTesting
  async function ScanMyHand() {
    console.log("ScanMyHand()");
    var cc = model.player1.hand.characters;
    var h_cand = undefined, p_cand = undefined, h_cand_idx = -999;
    var done = false;
    if (!is_my_move) return;
    
    for (var i=0; i<cc.length; i++) {
      var c = cc[i];
      if (c.card.card.classList.contains("glow")) {
        c.card.card.click();
        await sleep(233);
      }
    }
    
    for (var i=0; i<cc.length; i++) {
      var c = cc[i];
      
      if (!is_my_move) return;
      await sleep(233);
      c.card.card.click();
      await sleep(233);
      var pc = model.pool.characters;
      for (var j=0; j<pc.length; j++) {
        if (pc[j].card.card.classList.contains("glow")) {
          if (h_cand == undefined) {
            h_cand = c;
            p_cand = pc[j];
            if (!is_my_move) return;
            await sleep(233);
            p_cand.card.card.click();
            done = true;
            break;
          }
        }
      }
      if(done) {
        break;
      } else {
        if (c.card.card.classList.contains("glow")) {
          c.card.card.click();
        }
        await sleep(233);
      }
    }
    
    console.log(h_cand)
    console.log(p_cand)
    
    if (done) {
    } else if(false) { // 置换？
      
      if (h_cand != undefined && p_cand != undefined) {
        h_cand.card.card.click();
        p_cand.card.card.click();
        await sleep(700);
      } else {
        
        var card1 = model.player1.hand.characters[0];
        await sleep(300);
        card1.card.card.click();
        await sleep(300);
      }
    }
  }
  var is_autotesting = false;
  async function autotest() {
    if (is_autotesting) return;
    else is_autotesting = true;
    if (document.getElementById('finalcontainer').style.display == "block")
      await sleep(2666); // 等游戏结束通知消失
    while (true) {
      await sleep(1000);
      if (is_my_move) {
        if (document.getElementsByClassName('tableinfocontainer')[1].style.display == "block") {
          await sleep(200);
          model.player1.table.characters[0].card.card.click();
          await sleep(200);
        }
        if (document.getElementById('combobanner').style.display == "block") {
          await sleep(100);
          continue;
        } else if (document.getElementById('finalcontainer').style.display == "block") {
          await sleep(2666); // 等游戏结束通知消失
          document.getElementById('finalcontainer').click();
        } else {
          await sleep(300);
          await ScanMyHand();
        }
      }
    }
  }
  
  var AutoStartAutoTest = false;
  async function autostart() {
    while (true) {
      await sleep(1000);
      var x = document.getElementById('start_match'); 
      if (x.style.visibility == '') {
        x.click();
        console.log("Start clicked");
        while (true) {
          await sleep(1000);
          var y = document.getElementById('confirm_match');
          if (y.style.display != 'none') {
            y.click();
            console.log("Confirm clicked");
            return;
          }
        }
      }
    }
  }
  
  if (AutoStartAutoTest) {
    autostart();
  }
  
  // 默认打开多人模式
  document.getElementById('vs_player').click();
  document.getElementById('multiplayertype2').click();
  
  
  // sp evts
  
  socket.on('Match_GameSetupOffensive', () => { // 先手开局
    console.log('[先手选取特殊牌]');
    versus_rank = 1;
    gamesetup(true);
  });
  
  socket.on('Match_GameSetupDefensive', (p0c, p1c, poolc, repoc) => { // 后手开局
    console.log('[后手选取特殊牌]');
    versus_rank = 0;
    gamesetup(true);
  });
  
  function OtherPlayerSpecialCardFixup(other_sp) {
    model.player0.specials.clear();
    var temp_sp = new Repository("special");
    temp_sp.init();
    for (var i=0; i<other_sp.length; i++) {
      model.player0.specials.addChar(temp_sp.removeCharByID(other_sp[i]));
    }
    view.specials0.init();
    
    // --> Deck.initDeck
    for (var i = 0, idx = 0; i < model.player0.hand.characters.length; i++){
      if(!model.player0.hand.toSpecial(idx, model.player0.specials))
        idx ++;
    }
    // <-- Deck.initDeck
    
  }
  
  socket.on('Match_GameInitOffensive', (other_sp) => {
    console.log('[先手开局] other_sp='+other_sp);
    messenger.hideFinalNotice(); // If from restart
    OtherPlayerSpecialCardFixup(other_sp);
    console.log('MyCardsCount: ' + model.getMyCardsCount());
  });
  
  socket.on('Match_GameInitDefensive', (other_sp, snapshot) => {
    console.log('[后手开局], other_sp=' + other_sp);
    messenger.hideFinalNotice(); // if from restart
    
    //       p0sp中的0表示后手          后一个1表示自己
    snapshot.p0sp = PLAYER_SPECIALS[1].splice(0);
    console.log(snapshot)
    // 后手不用fixup，但是因为对方送来的snapshot里没有自己的specials，所以要加入
    
    controller.gamestartDefensive(snapshot);
    OtherPlayerSpecialCardFixup(other_sp);
    console.log('MyCardsCount: ' + model.getMyCardsCount());
  });
  
  socket.on('Game_SelfTurn', () => {
    if (remoteObtainActions == null || remoteObtainActions.length <= 0) { // for safety ?
      console.log('<<< 对方行动回放完了_');
      console.log('MyCardsCount: ' + model.getMyCardsCount());
      view.unblockGame();
    }
    
    is_my_move = true;
    
    var delay = 1;
    if (messenger.mayErase() != true) delay += 2;
    delayedFunc(function() {
      messenger.note('该你出牌了');
    }, delay);
    
    console.log('>>> 我方行动');
    console.log('MyCardsCount: ' + model.getMyCardsCount());
  });
  
  // barrier: 这个要等待对方的动作都播放完成
  socket.on('Game_OpponentTurn', () => {
    view.blockGame();
    is_my_move = false;
    
    var delay = 0;
    if (messenger.mayErase() != true) delay += 1;
    delayedFunc(function() {
      messenger.note('对方出牌');
    }, delay);
    
    console.log('>>> 对方行动');
    console.log('MyCardsCount: ' + model.getMyCardsCount());
  });
  
  // Action sequence from last turn
  // returns null if there are no more entries in the action buffer 
  function GetNextObtainAction() {
    var ret = null;
    if (remoteObtainActions.length < 1) ret = null;
    var a = remoteObtainActions[0];
    remoteObtainActions.splice(0, 1);
    var titel = '[replay] [' + remoteObtainActions.length + ' left] ';
    if (a[0] == "controller.obtain") {
      console.log(titel + 'controller.obtain ' + a[1] + ", " + a[2]);
      ret = [a[1], a[2]];
    } else if (a[0] == "controller.selectCopy" ||
               a[0] == "controller.selectSwap" ||
               a[0] == "controller.selectBan") {
      console.log(titel + a[0] + ' ' + a[1]);
      ret = a[1];
    } else if (a[0] == "obtainVector.trickSelector") {
      console.log(titel + " null ");
      ret = a[1];
    } else if (a[0] == "controller.postObtain") {
      var dealt_id = a[1];
      console.log("[Opponent's postObtain] " + dealt_id);
      model.dealOne(model.player0, dealt_id);
      ret = '';
    }
    if (remoteObtainActions.length <= 0 && is_my_move) {
      console.log('<<< 对方行动完了');
      console.log('MyCardsCount: ' + model.getMyCardsCount());
      view.unblockGame(); // 对方的动画未播放完亦即还没最后deal之前我方不能行动
    }
    return ret;
  }
  
  // Will replay a whole sequce of actions
  socket.on('Game_OpponentObtain', (obtain_actions) => {
    remoteObtainActions = obtain_actions;
    var obtain_ids = GetNextObtainAction(obtain_actions);
    controller.opponentObtain(obtain_ids[0], obtain_ids[1]);
    // 最后一个Deal
    GetNextObtainAction();
  });
  
  // DealOne 原本在这，现在移到上面的OpponentObtain中去了。
  
  socket.on('Game_OpponentDiscardOne', (discarded_id, added_id) => {
    console.log('OpponentDiscardOne ' + discarded_id + ", " + added_id);
    model.opponentDiscard(discarded_id, added_id);
  });
  
  socket.on('Game_OpponentRedeal', (pool_ids, repo_ids) => {
    console.log('Opponent Redeal');
    model.redeal(pool_ids, repo_ids);
  });
  
  socket.on('Game_OpponentGameEnd', () => {
    messenger.notifyFinal();
  });
  
  // AUTO TEST START
  //AUTOTEST_autostartmatch();
  var autotest_round = 1;
  var oppo_combo_notifications = 0;
  
  // ======================= AUTO TEST ==============================
  async function AUTOTEST_autostartmatch() {
    var done = false;
    while (done == false) {
      await sleep(1000);
      console.log('..');
      var x = document.getElementById('start_match');
      if (x.style.visibility == '') {
        x.click(); // 开始匹配
        console.log('[AUTOTEST] started matching process');
        while (done == false) {
          await sleep(1000);
          var y = document.getElementById('confirm_match');
          if (y.style.display != 'none') {
            y.click();
            console.log('[AUTOTEST] confirmed match');
            AUTOTEST_selectspecial();
            done = true;
          }
        }
      }
    }
  }
  
  async function AUTOTEST_selectspecial() {
    console.log('[AUTOTEST] round #' + autotest_round);
    console.log('[AUTOTEST] select special cards');
    var x = document.getElementById('gamestart');
    // Make some choices
    await sleep(1000)
    x.click();
    if (autotest_round == 1)
      document.getElementById('finalcontainer').click();
    delayedFunc(function() {
      AUTOTEST_maingame();
    }, 5);
  }
  
  function IsSelectionPanelPresent() {
    var x = document.getElementsByClassName('tableinfocontainer')[0];
    if (x.style.visibility == "visible") return true;
    else return false;
  }
  
  function IsInfoBannerPresent() {
    var x = document.getElementById('infobanner');
    if (x.style.visibility == "visible") return true;
    else return false;
  }
  
  function IsFinalNoticePresent() {
    if (document.getElementById('finalcontainer').style.visibility == "visible")
      return true;
    else return false;
  }
  
  function IsGameBlocked() {
    return (document.getElementById("blocker").style.visibility == "visible") ?
      true : false;
  }
  
  async function AUTOTEST_maingame() {
    var state = "in_game";
    while (true) {
      if (is_my_move != true && 
        (IsFinalNoticePresent() == false)) {
        await sleep(1000);
        continue;
      } else if (IsInfoBannerPresent() == true) {
        document.getElementById('infobanner').click();
        await sleep(1000);
        continue;
      } else if (IsGameBlocked() == true && (IsFinalNoticePresent() == false)) {
        await sleep(1000);
        continue;
      } else if (IsSelectionPanelPresent() == true) {
        var s = document.getElementsByClassName('tableinfocontainer')[0];
        var cands = s.children[1].children;
        cands[0].click();
        
        await sleep(1000);
        continue;
      } else if (IsFinalNoticePresent() == true) {
        var d = 20;
        
        autotest_round += 1;
        console.log('[AUTOTEST] 第' + autotest_round + '局');
        while (IsInfoBannerPresent() == true) {
          await sleep(1000);
        }
        await sleep(9999);
        console.log('[AUTOTEST] Clicked final container');
        document.getElementById('finalcontainer').click();
        document.getElementById('finalcontainer').visibility = null;
        while (document.getElementById('spselection').style.opacity == 0) {
          await sleep(1000);
        }
        console.log('[AUTOTEST] Clicked game start');
        document.getElementById('gamestart').click();
        await sleep(5000);
        
      } else {
        
        // 不能在对方的动画还没显示完的时候就点牌，不然会导致数据破损
        // 除非允许一方的点击能够打断另一方正在播放的提示信息
        if (oppo_combo_notifications > 0) {
          console.log('[AUTOTEST] 等对方的动画播完=' + oppo_combo_notifications);
          oppo_combo_notifications -= 1;
          await sleep(500);
          continue;
        }
        
        await sleep(2333);
        // If game ended then break
        
        var mychars = model.player1.hand.characters;
        var handc = null, poolc = null;
        var activated = false;
        for (var i=0; i<mychars.length; i++) {
          model.activate(mychars[i]);
          await sleep(700);
          var p = model.pool.characters;
          for (var j=0; j<p.length; j++) {
            if (p[j].card.card.classList.contains('glow')) {
              poolc = p[j];
              handc = mychars[i];
              activated = true;
              
              await sleep(400);
              model.activate(mychars[i]); // Deactivate
              await sleep(400);
              mychars[i].card.card.click();
              await sleep(400);
              poolc.card.card.click();
              break;
            }
          }
          
          if (activated == true) break;
        }
        
        if (activated == false) { // 可能是只有一张牌且无法打出的情况，点击之
          if (model.player1.hand.characters[0] != undefined)
            model.player1.hand.characters[0].card.card.click();
          await sleep(1000);
        }
        
        // do we need to select target ?
        
        
        await sleep(1000);
      }
        
      // obtain
    }
  }
  
</script>
